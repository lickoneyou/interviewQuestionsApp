const JSCORE = {
  'JS CORE': {
    'Типы данных JavaScript и структуры данных': {
      id: '51',
      title: 'Типы данных JavaScript и структуры данных',
      jsx: (
        <div>
          <ul>
            <b>JavaScript</b> имеет <b>8</b> встроенных типов данных:
            <li>null</li>
            <li>undefined</li>
            <li>boolean</li>
            <li>number</li>
            <li>string</li>
            <li>object</li>
            <li>symbol</li>
            <li>BigInt</li>
          </ul>
          <p>Структуры данных:</p>
          <p>
            <b>Массивы</b> — используются для хранения коллекции элементов,
            таких как числа, строки или объекты.
          </p>
          <p>
            <b>Стек</b> — это структура данных, которая работает по принципу{' '}
            <b>LIFO (Last In, First Out)</b>, что означает{' '}
            <span>«последним пришёл — первым вышел»</span> (push / pop).
          </p>
          <p>
            <b>Очередь</b> — это структура данных, которая работает по принципу{' '}
            <b>FIFO (First In, First Out)</b>, что означает{' '}
            <span>«первым пришёл — первым ушел»</span> (shift).
          </p>
          <p>
            <b>Связанный список</b> — это структура данных, которая состоит из
            узлов, каждый из которых содержит данные и ссылку на следующий узел
            в списке.
          </p>
          <ul>
            Существуют два основных типа связанных списков:
            <li>
              <b>Односвязный список</b> — структура данных, состоящая из
              элементов одного типа, последовательно связанных между собой
              указателями. Каждый элемент списка имеет указатель на следующий
              элемент. Последний элемент ни на что не указывает. Элемент, на
              который нет указателя, является первым в списке
            </li>
            <li>
              <b>Двусвязный список</b> — структура данных, в которой каждый
              элемент содержит указатель на следующий и предыдущий элементы. Это
              позволяет двигаться по списку в обоих направлениях
            </li>
          </ul>
          <p>
            <b>Деревья</b> — это структура, которая состоит из связанных узлов.
            Каждый узел дерева содержит данные и ссылки на его дочерние узлы.
            Вершина дерева называется корнем, узлы у которых нет потомков —
            листьями.
          </p>
          <p>
            <b>Бинарное дерево</b> — это структура данных, в которой каждый узел
            имеет не более двух детей, обычно обозначаемых как «левый ребёнок» и
            «правый ребёнок».
          </p>
          <p>
            <b>Графы</b> - это структура данных, которая представляет собой
            узлы, связанные рёбрами.
          </p>
          <ul>
            Графы бывают:
            <li>
              <b>Направленные</b> - в направленном графе рёбра имеют направление
            </li>
            <li>
              <b>Ненаправленные</b> - в ненаправленном графе рёбра не имеют
              направления
            </li>
          </ul>
        </div>
      ),
    },
    'Var, let или const? Проблемы областей видимости переменных': {
      id: '52',
      title: 'Var, let или const? Проблемы областей видимости переменных',
      jsx: (
        <div>
          <p>
            <b>const</b> и <b>let</b> имеют блочную область видимости,{' '}
            <b>var</b> имеет функциональную область видимости.
          </p>
        </div>
      ),
    },
    'Преобразование типов для примитивов': {
      id: '53',
      title: 'Преобразование типов для примитивов',
      jsx: (
        <div>
          <ul>
            Существует <b>3</b> наиболее широко используемых преобразования:
            <li>Строковое</li>
            <li>Числовое</li>
            <li>Логическое</li>
          </ul>
          <p>
            <b>String(value)</b> - переводит любое значение в строку.
          </p>
          <p>
            <b>Числовое</b> - происходит при математических операциях. Может
            быть вызвано с помощью <b>Number(value)</b>.
          </p>
          <table>
            <thead>
              <tr>
                <th>Значение</th>
                <th>Становится</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>
                  <b>undefined</b>
                </td>
                <td>
                  <b>NaN</b>
                </td>
              </tr>
              <tr>
                <td>
                  <b>null</b>
                </td>
                <td>
                  <b>0</b>
                </td>
              </tr>
              <tr>
                <td>
                  <b>true / false</b>
                </td>
                <td>
                  <b>1 / 0</b>
                </td>
              </tr>
              <tr>
                <td>
                  <b>string</b>
                </td>
                <td>
                  пробельные символы по краям обрезаются, если{' '}
                  <span>пустая строка</span> - <b>0</b>, если <span>число</span>{' '}
                  - <b>число</b>, инача <b>NaN</b>
                </td>
              </tr>
            </tbody>
          </table>
          <p>
            <b>Логическое</b> - происходит в логических операциях. Может быть
            вызвано с помощью <b>Boolean(value)</b>.
          </p>
          <table>
            <thead>
              <tr>
                <th>Значение</th>
                <th>Становится</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>
                  <b>0, null, undefined, NaN, ""</b>
                </td>
                <td>
                  <b>false</b>
                </td>
              </tr>
              <tr>
                <td>
                  <b>любое другое значение</b>
                </td>
                <td>
                  <b>true</b>
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      ),
    },
    'Операторы Сравнения': {
      id: '54',
      title: 'Операторы Сравнения',
      jsx: (
        <div>
          <table>
            <thead>
              <tr>
                <th>Свойство</th>
                <th>Оператор</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Больше / меньше</td>
                <td>
                  {'>'} / {'<'}
                </td>
              </tr>
              <tr>
                <td>Больше / меньше или равно</td>
                <td>
                  {'>='} / {'<='}
                </td>
              </tr>
              <tr>
                <td>Равно</td>
                <td>==</td>
              </tr>
              <tr>
                <td>Равно с проверкой типа</td>
                <td>===</td>
              </tr>
              <tr>
                <td>Не равно</td>
                <td>!=</td>
              </tr>
            </tbody>
          </table>
        </div>
      ),
    },
    'Логические операторы': {
      id: '55',
      title: 'Логические операторы',
      jsx: (
        <div>
          <p>
            ИЛИ <b>||</b> вернет первое <b>true</b> иначе <b>false</b>.
          </p>
          <p>
            И <b>&&</b> вернет первое <b>false</b> иначе <b>true</b>.
          </p>
          <p>
            НЕ <b>!</b> сначала приводит аргумент к логическому типу{' '}
            <b>true / false</b>, затем возвращает противоположное значение.
          </p>
          <p>
            Логическое присваивание ИЛИ <b>||=</b> если <b>a</b> ложно,
            присваивает <b>a</b> значение <b>b</b> <span>(a ||= b)</span>.
          </p>
          <p>
            Логическое присваивание И <b>&&=</b> присвоит <b>a</b> значение{' '}
            <b>b</b> только в том случае, если <b>a</b> истино.
          </p>
          <p>
            Оператор нулевого слияния <b>??</b> возвращает первый аргумент, если
            он не <b>null / undefined</b>, иначе второй.
          </p>
          <p>
            Оператор нулевого присваивания <b>??=</b> <span>(a ??= b)</span>{' '}
            присвоит <b>a</b> значение <b>b</b> только в том случае, если{' '}
            <b>a = null / undefined</b>.
          </p>
        </div>
      ),
    },
    'Условное Ветвление: if ?': {
      id: '56',
      title: 'Условное Ветвление: if ?',
      jsx: (
        <div>
          <p>
            Если <b>if(условие)</b> условие вернет <b>true</b> - выполнится тело{' '}
            <b>if</b> иначе <b>else</b>.
          </p>
          <p>
            Если нужно добавить еще условие, используется конструкция{' '}
            <b>if else(условие)</b>.
          </p>
          <p>
            Тернарный оператор: <b>УСЛОВИЕ</b> ? <b>ЗНАЧЕНИЕ 1</b> :{' '}
            <b>ЗНАЧЕНИЕ 2</b>
          </p>
          <p>
            Если условие вернет <b>true</b>, оператор вернет <b>значение 1</b>{' '}
            иначе оператор вернет <b>значение 2</b>.
          </p>
        </div>
      ),
    },
    'Циклы while и for': {
      id: '57',
      title: 'Циклы while и for',
      jsx: (
        <div>
          <p>
            Цикл <b>while</b> - проверяет условие перед каждой итерацией.
          </p>
          <p>
            Цикл <b>do..while</b> - проверяет условие после каждой итерации.
          </p>
          <p>
            Цикл <b>for( ; ; )</b> - проверяет условие перед каждой итерацией,
            есть возможность задать дополнительные настройки.
          </p>
          <p>
            Чтобы организовать бесконечный цикл, используют конструкцию{' '}
            <b>while(true)</b>.
          </p>
          <p>
            Любой цикл может быть прерван директивой <b>break</b>.
          </p>
          <p>
            Если на данной итерации цикла делать больше ничего не надо, но
            полностью прекращать цикл не следует - используют директиву{' '}
            <b>continue</b>.
          </p>
          <p>
            Для перебора всех свойст объекта используется цикл <b>for..in</b> .
            Синтаксис: <span>for(let key in object)</span>.
          </p>
          <p>
            Цикл для перебора массивов <b>for..of</b> не предоставляет доступ к
            номеру текущего элемента, только к его значению. Синтаксис:{' '}
            <span>for(let key of arr)</span>.
          </p>
        </div>
      ),
    },
    'Конструкция "switch"': {
      id: '58',
      title: 'Конструкция "switch"',
      jsx: (
        <div>
          <p>
            Конструкция <b>switch</b> имеет один или более блоков <b>case</b> и
            необязательный блок <b>default</b>.
          </p>
          <p>Синтаксис:</p>
          <pre>
            <div className="numbers">
              <code className="codeNumber">1</code>
              <code className="codeNumber">2</code>
              <code className="codeNumber">3</code>
              <code className="codeNumber">4</code>
              <code className="codeNumber">5</code>
              <code className="codeNumber">6</code>
              <code className="codeNumber">7</code>
              <code className="codeNumber">8</code>
              <code className="codeNumber">9</code>
              <code className="codeNumber">10</code>
              <code className="codeNumber">11</code>
            </div>
            <code>
              <code>
                switch(<b>x</b>){'{'}
              </code>
              <code>
                {'  '}case '<b>value1</b>':
              </code>
              <code className="comment">
                {'  '}
                {'//...'}
              </code>
              <code>{'    '}break</code>
              <code>
                {'  '}case '<b>value2</b>'
              </code>
              <code className="comment">
                {'  '}
                {'//...'}
              </code>
              <code>{'    '}break</code>
              <code>{'  '}default</code>
              <code className="comment">
                {'  '}
                {'//...'}
              </code>
              <code>{'    '}break</code>
              <code>{'}'}</code>
            </code>
          </pre>
        </div>
      ),
    },
    Функции: {
      id: '59',
      title: 'Функции',
      jsx: (
        <div>
          <p>
            Функции нужны для того, чтобы не повторять один и тот же код
            несколько раз.
          </p>
          <p>
            Синтаксис <b>function declaration</b>:
          </p>
          <pre>
            <div className="numbers">
              <code className="codeNumber">1</code>
              <code className="codeNumber">2</code>
              <code className="codeNumber">3</code>
            </div>
            <code>
              <code>
                function <b>fn</b>(<b>a</b>) {'{'}
              </code>
              <code>
                {'  '}return <b>a</b>
              </code>
              <code>{'}'}</code>
            </code>
          </pre>
          <p>
            Синтаксис <b>function expression</b>:
          </p>
          <pre>
            <div className="numbers">
              <code className="codeNumber">1</code>
              <code className="codeNumber">2</code>
              <code className="codeNumber">3</code>
            </div>
            <code>
              <code>
                const <b>fn</b> = function(<b>a</b>) {'{'}
              </code>
              <code>
                {'  '}return <b>a</b>
              </code>
              <code>{'}'}</code>
            </code>
          </pre>
          <p>
            Синтаксис <b>arrow function</b>:
          </p>
          <pre>
            <div className="numbers">
              <code className="codeNumber">1</code>
            </div>
            <code>
              <code>
                const <b>fn</b> = (<b>a</b>, <b>b</b>) {'=>'} <b>a</b> +{' '}
                <b>b</b>
              </code>
            </code>
          </pre>
          <p>
            У стрелочных функций нет собственного <b>this</b>, нет{' '}
            <b>arguments</b> и их нельзя вызвать с помощью ключевого слова{' '}
            <b>new</b>, у них нет <b>super</b> и свойства <b>prototype</b>.
          </p>
        </div>
      ),
    },
    'try…catch': {
      id: '510',
      title: 'try…catch',
      jsx: (
        <div>
          <p>
            Конструкция <b>try..catch</b> позволяет обрабатывать ошибки во время
            исполнения кода. Она позволяет запустить код и перехватить ошибки,
            которые могут в нем возникнуть.
          </p>
          <p>Синтаксис:</p>
          <pre>
            <div className="numbers">
              <code className="codeNumber">1</code>
              <code className="codeNumber">2</code>
              <code className="codeNumber">3</code>
              <code className="codeNumber">4</code>
              <code className="codeNumber">5</code>
              <code className="codeNumber">6</code>
              <code className="codeNumber">7</code>
              <code className="codeNumber">8</code>
            </div>
            <code>
              <code>
                <b>try</b> {'{'}
              </code>
              <code className="comment">
                {'  '}
                {'// исполняем код'}
              </code>
              <code>
                {'}'} <b>catch</b>(<b>err</b>) {'{'}
              </code>
              <code className="comment">
                {'  '}
                {'// если ошибка случается'}
              </code>
              <code>
                {'}'} <b>finally</b> {'{'}
              </code>
              <code className="comment">
                {'  '}
                {'// выполняется всегда'}
              </code>
              <code className="comment">
                {'  '}
                {'// после'} <b className="comment">try..catch</b>
              </code>
              <code>{'}'}</code>
            </code>
          </pre>
          <p>
            Секций <b>catch</b> или <b>finally</b> может не быть, то есть
            короткие конструкции <b>try..catch</b> или <b>try..finally</b> также
            корректны.
          </p>
          <ul>
            Объекты ошибок содержат следующие свойства:
            <li>
              <b>message</b> - сообщение
            </li>
            <li>
              <b>name</b> - имя ошибки
            </li>
            <li>
              <b>stack</b> - стек на момент ошибки
            </li>
          </ul>
          <p>
            Мы можем также генерировать собственные ошибки, используя оператор{' '}
            <b>throw</b>. Аргументом <b>throw</b> может быть что угодно, но
            обычно это объект ошибки, наследуемый от встроенного класса{' '}
            <b>Error</b>.
          </p>
        </div>
      ),
    },
    'Строгий режим': {
      id: '511',
      title: 'Строгий режим',
      jsx: (
        <div>
          <ul>
            Для того чтобы воспользоваться <b>строгим режимом</b> нужно написать
            команду <b>'use strict'</b> в начале скрипта.
            <li>
              <b>Нельзя</b> создавать переменную не объявив ее ключевым словом
            </li>
            <li>
              При строгом режиме <b>this</b> в функциях указывает на{' '}
              <b>undefined</b>
            </li>
          </ul>
        </div>
      ),
    },
    Массивы: {
      id: '512',
      title: 'Массивы',
      jsx: (
        <div>
          <p>
            <b>Массив</b> в JavaScript — это особая структура данных, которая
            используется для хранения различных элементов.
          </p>
          <p>Методы:</p>
          <p>
            <b>some()</b> проверяет, удовлетворяет ли какой-либо элемент массива
            условию, заданному в передаваемой функции. Он вернет значение{' '}
            <b>true</b>, если хотя бы один элемент совпадет с проверяемой
            функцией, и значение <b>false</b> — если нет.
          </p>
          <p>
            <b>reduce()</b> принимает функцию, которая имеет в качестве
            аргумента аккумулятор и значение. Он применяет функцию к
            аккумулятору и каждому значению массива, возвращает{' '}
            <b>аккумулятор</b>.
          </p>
          <p>
            <b>every()</b> проверяет, удовлетворяют ли все элементы массива
            условию, заданному в передаваемой функции. Он вернет значение{' '}
            <b>true</b>, если каждый элемент совпадет с проверяемой функцией, и
            значение
            <b>false</b> — если нет.
          </p>
          <p>
            <b>map()</b> принимает функцию в качестве параметра и создает новый
            массив с результатом вызова указанной функции для каждого элемента.
          </p>
          <p>
            <b>flat()</b> сглаживает вложенные массивы в массив верхнего уровня.
          </p>
          <p>
            <b>filter()</b> принимает функцию в качестве параметра и возвращает
            новый массив, содержащий все элементы массива, для которого функция
            вернула <b>true</b>.
          </p>
          <p>
            <b>forEach()</b> применяет функцию к каждому элементу массива.
          </p>
          <p>
            <b>findIndex()</b> - принимает функцию в качестве параметра и в
            дальнейшем применяет ее к массиву. Он возвращает индекс найденного
            элемента, если элемент удовлетворяет условию проверяющей функции,
            переданной в качестве аргумента. Если не удовлетворяет, возвращается{' '}
            <b>–1</b>.
          </p>
          <p>
            <b>find()</b> принимает функцию в качестве аргумента и возвращает
            элемент для которого функция вернула <b>true</b> иначе{' '}
            <b>undefined</b>.
          </p>
          <p>
            <b>sort()</b> принимает функцию в качестве параметра. Он сортирует
            элементы массива и возвращает их.
          </p>
          <p>
            <b>concat()</b> объединяет два или более массива/значения и
            возвращает новый массив.
          </p>
          <p>
            <b>fill()</b> заполняет все элементы массива одинаковым значением{' '}
            <b>fill(value, start, end)</b>.
          </p>
          <p>
            <b>includes()</b> возвращает значение <b>true</b>, если массив
            содержит определенный элемент, иначе <b>false</b>.
          </p>
          <p>
            <b>reverse()</b> переворачивает массив.
          </p>
          <p>
            <b>push()</b> добавляет элемент в конец массива.
          </p>
          <p>
            <b>shift()</b> добавляет элемент в начало массива.
          </p>
          <p>
            <b>pop()</b> удаляет последний элемент.
          </p>
          <p>
            <b>unshift()</b> добавляет элемент в массив на первую позицию.
          </p>
          <p>
            <b>join()</b> переводит массив в строку.
          </p>
        </div>
      ),
    },
    Объекты: {
      id: '513',
      title: 'Объекты',
      jsx: (
        <div>
          <p>
            <b>Объект</b> - это ассоциативный массив с рядом дополнительных
            возможностей.
          </p>
          <ul>
            Он хранит свойства в формате <span>ключ / значение</span> где:
            <li>
              Ключи должны быть <b>строками</b> или <b>символами</b>
            </li>
            <li>
              Значения могут быть <b>любого типа</b>
            </li>
          </ul>
          <p>
            Получить доступ к свойству мы можем через <b>точку</b> или{' '}
            <b>квадратные скобки</b>.
          </p>
          <p>
            Удалить свойство - <b>delete</b>.
          </p>
          <p>
            Проверка существования свойства <b>"key in obj"</b>.
          </p>
          <p>
            Перебрать свойства <b>for(let key in object)</b>.
          </p>
          <p>
            Клонировать объект можно с помощью: <b>Object.assign</b>,{' '}
            <b>рекурсии</b>, <b>_.cloneDeep(obj)</b> (из библиотеки JavaScript
            lodash), <b>structuredClone()</b>,{' '}
            <b>JSON.parse(JSON.stringify(obj))</b>
          </p>
        </div>
      ),
    },
    'Сборка Мусора': {
      id: '514',
      title: 'Сборка Мусора',
      jsx: (
        <div>
          <p>
            <b>Сборка мусора</b> выполняется автоматически. Мы не можем ускорить
            или предотвратить ее.
          </p>
          <p>
            Объекты сохраняются в памяти пока они <span>достижимы</span>.
          </p>
        </div>
      ),
    },
    This: {
      id: '515',
      title: 'This',
      jsx: (
        <div>
          <p>
            Значение <b>this</b> во время вызова является <b>объект</b>.
          </p>
          <p>
            Стрелочные функции являются особенными - у них нет <b>this</b>.
            Когда внутри стрелочной функции обращаются к <b>this</b>, то его
            значение берется извне.
          </p>
        </div>
      ),
    },
    'Оператор new': {
      id: '516',
      title: 'Оператор new',
      jsx: (
        <div>
          <p>
            <b>Функции конструкторы</b> следует вызывать только с помощью{' '}
            <b>new</b>. Такой вызов подразумевает создание <b>this</b>, привязку
            к нему <b>пустого объекта</b>, и возврат этого <b>this</b>.
          </p>
        </div>
      ),
    },
    'Именованное функциональное выражение(Named Function Expression)': {
      id: '517',
      title: 'Именованное функциональное выражение(Named Function Expression)',
      jsx: (
        <div>
          <p>
            <b>Named Function Expression</b> — расширение функциональных
            выражений в JavaScript, позволяющее именовать функцию, созданную как
            часть выражения (FunctionExpression).
          </p>
          <p>
            <b>NFE ошибка</b> - ReferenceError
          </p>
        </div>
      ),
    },
    Прототипы: {
      id: '518',
      title: 'Прототипы',
      jsx: (
        <div>
          <p>
            <b>__proto__</b> - это свойство, которое является ссылкой на
            прототип объекта.
          </p>
          <p>
            <b>prototype</b> это свойство функции которое позволяет добавлять
            что-то в конструктор.
          </p>
        </div>
      ),
    },
    Классы: {
      id: '519',
      title: 'Классы',
      jsx: (
        <div>
          <p>Синтаксис:</p>
          <pre>
            <div className="numbers">
              <code className="codeNumber">1</code>
              <code className="codeNumber">2</code>
              <code className="codeNumber">3</code>
              <code className="codeNumber">4</code>
              <code className="codeNumber">5</code>
              <code className="codeNumber">6</code>
              <code className="codeNumber">7</code>
            </div>
            <code>
              <code>
                class <b>Class</b> {'{'}
              </code>
              <code>
                {'  '}constructor(<b>...</b>) {'{'}
              </code>
              <code className="comment">
                {'    '}
                {'//...'}
              </code>
              <code>
                {'  '}
                {'}'}
              </code>
              <code>
                {'  '}
                <b>method1</b>(<b>...</b>) {'{}'}
              </code>
              <code>
                {'  '}
                <b>method2</b>(<b>...</b>) {'{}'}
              </code>
              <code>{'}'}</code>
            </code>
          </pre>
          <p>
            <b>Class</b> технически является функцией (той, которую мы
            определяем как <b>constructor</b>) в то время как методы - геттеры и
            сеттеры записываются <b>Class.prototype</b>.
          </p>
          <p>
            Основой ООП являются <b>класс</b> и <b>конструктор</b>. Конструктор
            - это функция, которая служит шаблоном для построения объекта. Это
            функция, которая вызывается с ключевым словом <b>New</b>, в
            результате этого создается пустой объект, к которому привязывается{' '}
            <b>this</b>.
          </p>
          <ul>
            Неявно просходит:
            <li>Создается новый объект</li>
            <li>
              На этот объект устанавливается <b>this</b>
            </li>
            <li>Функция возвращает этот объект</li>
          </ul>
          <p>
            Оператор <b>instanceof</b> позволяет проверить, принадлежит ли
            объект указанному классу, с учетом наследования.
          </p>
        </div>
      ),
    },
    'Асинхронный JavaScript': {
      id: '520',
      title: 'Асинхронный JavaScript',
      jsx: (
        <div>
          <p>
            Функция, которая передается как аргумент в другую функцию,
            называется <b>callback-функцией</b>, а функция которя ее принимает
            называется <b>функцией высшего порядка</b>.
          </p>
          <p>
            <b>Промис</b> - это объект, который содержит будущее значение
            асинхронной операции.
          </p>
          <ul>
            <b>Промис</b> имеет 3 состояния:
            <li>
              <b>Pending</b> (ожидание) - промис ожидает завершение асинхронной
              операции
            </li>
            <li>
              <b>Resolved / Fullfild</b> - промис решен, асинхронная операция
              завершила свое выполнение
            </li>
            <li>
              <b>Rejected</b> (отклоненный) - промис отклонен, произошла ошибка
              в процессе выполнения
            </li>
          </ul>
          <p>Синтаксис:</p>
          <pre>
            <div className="numbers">
              <code className="codeNumber">1</code>
              <code className="codeNumber">2</code>
              <code className="codeNumber">3</code>
            </div>
            <code>
              <code>
                const <b>promise</b> = new <b>Promise</b>((<b>res</b>,{' '}
                <b>rej</b>) {'=>'} {'{'}
              </code>
              <code className="comment">
                {'  '}
                {'//...'}
              </code>
              <code>
                {'}'}
                {')'}
              </code>
            </code>
          </pre>
          <p>
            <b>Promise.all()</b> - этот метод принимает массив промисов и
            возвращает массив их результатов.
          </p>
          <p>
            <b>Promise.race()</b> - этот метод принимает массив промисов и
            возвращает один новый промис, который будет выполненным или
            отклоненным, если отклоненный промис встретится раньше.
          </p>
          <ul>
            Ключевое слово <b>async</b> перед объявлением функции:
            <li>
              Обязывает ее всегда возвращать <b>промис</b>
            </li>
            <li>
              Позволяет использовать <b>await</b> в теле
            </li>
          </ul>
          <ul>
            Ключевое слово <b>await</b> перед промисом заставит JavaScript
            дождаться выполнения, после чего:
            <li>
              Если промис завершается с ошибкой, будет сгенерировано исключение,
              как если бы на этом месте находилось <b>throw</b>
            </li>
            <li>Иначе вернется результат промиса</li>
          </ul>
          <p>
            <b>CallbackHell</b> - это когда в колбеках большая вложенность из-за
            чего трудно понимать код.
          </p>
          <ul>
            <b>CallbackHell</b> решается:
            <li>Комментированием кода</li>
            <li>Разделением больших функций на несколько маленьких</li>
            <li>Использованием асинхронных функций</li>
          </ul>
          <p>
            <b>Промиссификация</b> - позволяет избежать использования{' '}
            <b>callback-функций</b>, что делает код более читаемым и
            поддерживаемым.
          </p>
          <p>
            <b>Event loop</b> - это бесконечный цикл, который ожидает задачи,
            выполняет их, а затем ожидает поступление новых задач.
          </p>
          <p>
            Есть <b>call stack</b>, который по очереди обрабатывает синхронные
            события.
          </p>
          <p>
            Клики, таймауты регистрируются в <b>web api</b> и когда происходит
            событие попадают в <b>call stack</b>, и выполняются, когда{' '}
            <b>call stack</b> очищается.
          </p>
          <ul>
            <b>Call stack</b> делится на:
            <li>
              <b>Микротаски</b> (промисы, queueMicrotask, mutationobserver)
            </li>
            <li>
              <b>Макротаски</b> (таймеры, события)
            </li>
          </ul>
          <p>
            <b>Всегда</b> сначала выполняются все микротаски, затем <b>один</b>{' '}
            макротаск.
          </p>
        </div>
      ),
    },
    Генераторы: {
      id: '521',
      title: 'Генераторы',
      jsx: (
        <div>
          <p>
            <b>Генераторы</b> создаются при помощи функций генераторов.
          </p>
          <pre>
            <div className="numbers">
              <code className="codeNumber">1</code>
              <code className="codeNumber">2</code>
              <code className="codeNumber">3</code>
            </div>
            <code>
              <code>
                function<b>*</b> fn() {'{'}
              </code>
              <code className="comment">
                {'  '}
                {'//...'}
              </code>
              <code>{'}'}</code>
            </code>
          </pre>
          <p>
            Внутри генераторов существует оператор <b>yield</b>.
          </p>
          <p>
            Внешний код и <b>генератор</b> обмениваются промежуточными данными
            посредством вызовом <b>next / yield</b>.
          </p>
        </div>
      ),
    },
    'Модули Иморт Экспорт': {
      id: '522',
      title: 'Модули Иморт Экспорт',
      jsx: (
        <div>
          <p>
            Для того, чтобы браузер понимал, что мы экспортируем модули,
            необходимо в тег <b>script</b>, где имеется модуль, добавить атрибут{' '}
            <b>type="module"</b>. Но обычно используется <b>webpack</b> и
            добавлять ничего не нужно.
          </p>
          <p>
            <b>Export</b> можно использовать в момент объявления функции,
            переменной или класса.
          </p>
          <pre>
            <div className="numbers">
              <code>1</code>
              <code>2</code>
              <code>3</code>
              <code>4</code>
              <code>5</code>
              <code>6</code>
              <code>7</code>
              <code>8</code>
              <code>9</code>
            </div>
            <code>
              <code>
                <b>export</b> function <b>fn</b>() {'{'}
              </code>
              <code className="comment">
                {'  '}
                {'//...'}
              </code>
              <code>{'}'}</code>
              <code>{'  '}</code>
              <code>
                <b>export</b> const <b>num</b> = 4
              </code>
              <code>{'  '}</code>
              <code>
                <b>export</b> class <b>User</b>() {'{'}
              </code>
              <code className="comment">
                {'  '}
                {'//...'}
              </code>
              <code>{'}'}</code>
            </code>
          </pre>
          <p>
            Для больших модулей удобнее использовать группированный экспорт.
          </p>
          <pre>
            <div className="numbers">
              <code>1</code>
            </div>
            <code>
              <code>
                <b>export</b> {'{'} <b>fn</b>, <b>num</b>, <b>User</b> {'}'}
              </code>
            </code>
          </pre>
          <p>
            В случае, когда из файла экспортируется только одна сущность,
            удобнее использовать <span>экспорт по умолчанию</span>.
          </p>
          <pre>
            <div className="numbers">
              <code>1</code>
              <code>2</code>
              <code>3</code>
              <code>4</code>
              <code>5</code>
            </div>
            <code>
              <code>
                function <b>fn</b> () {'{'}
              </code>
              <code className="comment">
                {'  '}
                {'//...'}
              </code>
              <code>{'}'}</code>
              <code>{'  '}</code>
              <code>
                <b>export</b> default <b>fn</b>
              </code>
            </code>
          </pre>
          <p>
            Чтобы импортировать какой-либо метод, необходимо воспользоваться
            инструкцией <b>import</b>, указав интересующие части модуля и путь
            до него.
          </p>
          <pre>
            <div className="numbers">
              <code>1</code>
            </div>
            <code>
              <code>
                <b>import</b> {'{'} <b>fn</b>, <b>num</b> {'}'} <b>from</b>{' '}
                './путь'
              </code>
            </code>
          </pre>
          <p>
            Для изменения метода в момент <b>импорта / экспорта</b> существует
            инструкция <b>as</b>.
          </p>
          <p>
            Можно импортировать все содержимое модуля в переменную и обращаться
            к частям модуля как с свойствам переменной.
          </p>
          <pre>
            <div className="numbers">
              <code>1</code>
            </div>
            <code>
              <code>
                <b>import</b> * <b>as el</b> from './путь'
              </code>
            </code>
          </pre>
        </div>
      ),
    },
    'FetchAPI - Интерфейсы веб API, XMLHttpRequest': {
      id: '523',
      title: 'FetchAPI - Интерфейсы веб API, XMLHttpRequest',
      jsx: (
        <div>
          <p>
            Для того, чтобы сделать сетовой запрос можно использовать метод{' '}
            <b>fetch()</b>.
          </p>
          <p>
            Первым параметром он принимает <b>URL</b> для отправки запроса,
            вторым <b>options</b> - это объект с дополнительными параметрами
            (метод, заголовки, тело). Без <b>options</b> - это будет простой{' '}
            <b>GET</b> запрос, который получит содержимое по <b>URL</b>.
          </p>
          <p>
            <b>XMLHttpRequest</b> - это встроенный в браузер объект, который
            дает возможность делать HTTP запросы к серверу без перезагрузки
            страницы.
          </p>
          <p>
            Чтобы создать запрос, нужно создать конструктор <b>new</b>{' '}
            XMLHttpRequest.
          </p>
          <p>
            Чтобы инициализировать его, нужно воспользоваться методом{' '}
            <b>open</b>, в котором передаются параметры <b>method</b> (обычно{' '}
            <b>GET</b> или <b>POST</b>), <b>URL</b>.
          </p>
          <p>
            Чтобы сделать запрос используется метод <b>send</b>, в котором можно
            отправить тело запроса.
          </p>
          <p>
            Слушать событие можно при помощь события <b>load</b>, в реквесте
            нужно обратиться к свойству <b>response</b>.
          </p>
        </div>
      ),
    },
    Замыкание: {
      id: '524',
      title: 'Замыкания',
      jsx: (
        <div>
          <b>Замыкание</b> - это способность функции в JavaScript{' '}
          <span>запоминать лексическое окружение</span>, в котором она была
          создана.
        </div>
      ),
    },
    Рекурсия: {
      id: '525',
      title: 'Рекурсия',
      jsx: (
        <div>
          <p>
            <b>Рекурсия</b> - это возможность функции вызвать саму себя.
          </p>
        </div>
      ),
    },
    'Map, Set, WeekMap, WeekSet': {
      id: '526',
      title: 'Map, Set, WeekMap, WeekSet',
      jsx: (
        <div>
          <p>
            <b>Map</b> – это коллекция ключ/значение, как и <b>Object</b>. Но
            основное отличие в том, что Map позволяет использовать ключи любого
            типа.
          </p>
          <ul>
            Методы и свойства:
            <li>
              <b>new Map()</b> – создаёт коллекцию
            </li>
            <li>
              <b>map.set(key, value)</b> – записывает по ключу <b>key</b>{' '}
              значение <b>value</b>
            </li>
            <li>
              <b>map.get(key)</b> – возвращает значение по ключу или{' '}
              <b>undefined</b>, если ключ <b>key</b> отсутствует
            </li>
            <li>
              <b>map.has(key)</b> – возвращает <b>true</b>, если ключ <b>key</b>{' '}
              присутствует в коллекции, иначе <b>false</b>
            </li>
            <li>
              <b>map.delete(key)</b> – удаляет элемент (пару «ключ/значение») по
              ключу <b>key</b>
            </li>
            <li>
              <b>map.clear()</b> – очищает коллекцию от всех элементов
            </li>
            <li>
              <b>map.size</b> – возвращает текущее количество элементов
            </li>
          </ul>
          <p>
            <b>Set</b> – это особый вид коллекции, где каждое значение может
            появляться только <span>один раз</span>.
          </p>
          <ul>
            Методы:
            <li>
              <b>new Set(iterable)</b> – создаёт <b>Set</b>, и если в качестве
              аргумента был предоставлен итерируемый объект (обычно это массив),
              то копирует его значения в новый <b>Set</b>
            </li>
            <li>
              <b>set.add(value)</b> – добавляет значение (если оно уже есть, то
              ничего не делает), возвращает тот же объект <b>set</b>
            </li>
            <li>
              <b>set.delete(value)</b> – удаляет значение, возвращает{' '}
              <b>true</b>, если <b>value</b> было в множестве на момент вызова,
              иначе <b>false</b>
            </li>
            <li>
              <b>set.has(value)</b> – возвращает <b>true</b>, если значение
              присутствует в множестве, иначе <b>false</b>
            </li>
            <li>
              <b>set.clear()</b> – удаляет все имеющиеся значения
            </li>
            <li>
              <b>set.size</b> – возвращает количество элементов в множестве
            </li>
          </ul>
          <p>
            <b>WeakMap</b> – это <b>Map</b>-подобная коллекция, позволяющая
            использовать в качестве ключей только объекты, и автоматически
            удаляющая их вместе с соответствующими значениями, как только они
            становятся недостижимыми иными путями.
          </p>
          <p>
            <b>WeakSet</b> – это <b>Set</b>-подобная коллекция, которая хранит
            только объекты и удаляет их, как только они становятся недостижимыми
            иными путями.
          </p>
          <p>
            <b>WeakMap</b> и <b>WeakSet</b> используются как вспомогательные
            структуры данных в дополнение к «основному» месту хранения объекта.
            Если объект удаляется из основного хранилища и нигде не
            используется, кроме как в качестве ключа в <b>WeakMap</b> или в{' '}
            <b>WeakSet</b>, то он будет удалён автоматически.
          </p>
        </div>
      ),
    },
    BOM: {
      id: '528',
      title: 'BOM',
      jsx: (
        <div>
          <p>
            <b>BOM</b> - это дополнительные объекты предоставляемые браузером,
            чтобы работать со всем, кроме документа.
          </p>
          <p>
            <b>navigator</b> - информация о браузере.
          </p>
          <p>
            <b>screen</b> - информация о экране пользователя.
          </p>
          <p>
            <b>location</b> - информация о текущем расположении документа.
          </p>
          <p>
            <b>history</b> - для перемещения в браузере.
          </p>
        </div>
      ),
    },
    Ошибки: {
      id: '529',
      title: 'Ошибки',
      jsx: (
        <div>
          <ul>
            <li>
              <b>SyntaxError</b> - опечатки
            </li>
            <li>
              <b>ReferenceError</b> - обращения к несуществующей переменной
            </li>
            <li>
              <b>TypeError</b> - обращения к несуществующим свойствам
            </li>
          </ul>
        </div>
      ),
    },
    Зависимости: {
      id: '530',
      title: 'Зависимости',
      jsx: (
        <div>
          <p>
            <b>Dependencies</b> (зависимости) в файле <b>package.json</b>{' '}
            являются объектом, содержащим <b>ключ-значение</b>.
          </p>
          <p>
            <b>Dependencies</b> - то, что необходимо в продакшене (плагины,
            библиотеки).
          </p>
          <p>
            <b>devDependencies</b> - то, что необходимо для сборки проекта
            (минификаторы, транпиляторы, компиляторы).
          </p>
          <p>
            <b>peerDependencies</b> - используются для указания зависимостей,
            которые должны быть установлены совместно с вашим пакетом.
          </p>
          <p>
            <b>Значение версий</b> - комбинация из 3-ех цифр, разделенныйй
            точками <b>a.b.c</b>.
          </p>
          <p>
            <b>Первая цифра</b> - определяет мажорную версию пакета. Это
            означает, что такая версия содержит значительные модификации кода,
            способные привести к критическим изменениям API.
          </p>
          <p>
            <b>Вторая цифра</b> - определяет минорную версию пакета, которая
            содержит незначительные изменения, не приводящие к изменения API.
          </p>
          <p>
            <b>Третья цифра</b> - определяет версию патча, который обычно
            содержит исправления ошибок.
          </p>
          <p>
            <b>Коретка</b> (<b>^</b>) - этот символ означает, что при обновлении
            пакетов, упомянутых в <b>package.json</b>, с помощью{' '}
            <b>npm update</b> обновятся только патчи и минорные изменения.
          </p>
          <p>
            <b>Тильда</b> (<b>~</b>) - этот символ означает, что для пакета
            разрешены только обновления патча.
          </p>
          <p>
            Для установки последней доступной версии пакета используется{' '}
            <b>npm i ...@latest</b>.
          </p>
        </div>
      ),
    },
    Символы: {
      id: '531',
      title: 'Символы',
      jsx: (
        <div>
          <p>
            <b>Символ</b> - примитивный тип данных, использующийся для создания
            уникальных идентификаторов.
          </p>
          <p>
            <b>Символы</b> создаются вызовом функции <b>Symbol()</b>, в которую
            можно передать описание (имя) символа.
          </p>
          <ul>
            Символы имеют два основных варианта использования:
            <li>«Скрытые» свойства объектов</li>
            <li>
              Cистемныe символы: <b>Symbol.iterator</b> для итераторов,{' '}
              <b>Symbol.toPrimitive</b> для настройки преобразования объектов в
              примитивы и другие
            </li>
          </ul>
          <p>
            <b>Object.getOwnPropertySymbols(obj)</b> – с его помощью можно
            получить все свойства объекта с ключами-символами.
          </p>
        </div>
      ),
    },
    IIFE: {
      id: '532',
      title: 'IIFE',
      jsx: (
        <div>
          <p>
            <b>IIFE</b> это функция, которая выполняется сразу же после того,
            как она была определена.
          </p>
          <p>
            Способы создания <b>IIFE</b>:
          </p>
          <pre>
            <div className="numbers">
              <code>1</code>
              <code>2</code>
              <code>3</code>
              <code>4</code>
              <code>5</code>
              <code>6</code>
              <code>7</code>
              <code>8</code>
              <code>9</code>
              <code>10</code>
              <code>11</code>
            </div>
            <code>
              <code>
                (<b>function</b>() {'{'}
              </code>
              <code>{'  '}console.log(1)</code>
              <code>{'}'})();</code>
              <code>{'  '}</code>
              <code>
                !<b>function</b>() {'{'}
              </code>
              <code>{'  '}console.log(2)</code>
              <code>{'}'}();</code>
              <code>{'  '}</code>
              <code>
                +<b>function</b>() {'{'}
              </code>
              <code>{'  '}console.log(3)</code>
              <code>{'}'}();</code>
            </code>
          </pre>
        </div>
      ),
    },
    'Apply, call, bind, декоратор': {
      title: 'Apply, call, bind, декоратор',
      id: '533',
      jsx: (
        <div>
          <p>Call:</p>
          <pre>
            <div className="numbers">
              <code>1</code>
            </div>
            <code>
              <code>
                func.<b>call</b>(context, arg1, arg2, ...)
              </code>
            </code>
          </pre>
          <p>Apply:</p>
          <pre>
            <div className="numbers">
              <code>1</code>
            </div>
            <code>
              <code>
                func.<b>apply</b>(context, [arg1, arg2, ...])
              </code>
            </code>
          </pre>
          <p>Bind:</p>
          <pre>
            <div className="numbers">
              <code>1</code>
              <code>2</code>
              <code>3</code>
            </div>
            <code>
              <code>
                let <b>fn</b> = func.<b>apply</b>(context, arg1, arg2, ...)
              </code>
              <code>{'  '}</code>
              <code>
                <b>fn</b>()
              </code>
            </code>
          </pre>
          <p>Декоратор:</p>
          <pre>
            <div className="numbers">
              <code>1</code>
              <code>2</code>
              <code>3</code>
              <code>4</code>
              <code>5</code>
              <code>6</code>
              <code>7</code>
              <code>8</code>
              <code>9</code>
              <code>10</code>
              <code>11</code>
              <code>12</code>
              <code>13</code>
              <code>14</code>
              <code>15</code>
              <code>16</code>
              <code>17</code>
              <code>18</code>
              <code>19</code>
            </div>
            <code>
              <code>
                let <b>fn</b> = (x) {'=>'} {'{'}
              </code>
              <code>
                {'  '}
                <b>return</b> x
              </code>
              <code>{'}'}</code>
              <code>{'  '}</code>
              <code>
                const <b>decorator</b> = (fn) {'=>'} {'{'}
              </code>
              <code>
                {'  '}const <b>map</b> = <b>new</b> Map()
              </code>
              <code>{'  '}</code>
              <code>
                {'  '}return (x) {'=>'} {'{'}
              </code>
              <code>
                {'    '}if(map.<b>has</b>(x)){'{'}
              </code>
              <code>
                {'      '}return map.<b>get</b>(x)
              </code>
              <code>
                {'    '}
                {'}'}
              </code>
              <code>{'  '}</code>
              <code>
                {'    '}const <b>res</b> = <b>fn</b>(x)
              </code>
              <code>
                {'    '}map.<b>set</b>(x, res)
              </code>
              <code>
                {'    '}return <b>res</b>
              </code>
              <code>
                {'  '}
                {'}'}
              </code>
              <code>{'}'}</code>
              <code>{'  '}</code>
              <code>
                fn = <b>decorator</b>(fn)
              </code>
            </code>
          </pre>
        </div>
      ),
    },
  },
}

export default JSCORE
